<html>
	<head>
		<script type="text/javascript" src="js/three.min.js"></script>
		<script type="text/javascript" src="js/physi.js"></script>
		<script>
			'use strict';
	
			Physijs.scripts.worker = 'js/physijs_worker.js';
			Physijs.scripts.amo = 'js/ammo.js';

			var initScene,renderer,scene,camera,light,table_material, table,render,spawnBall,ball;
			var forceVelocity=1;

			initScene = function(){
				renderer=new THREE.WebGLRenderer({antialias:true});
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMapEnabled=true;
				renderer.shadowMapSoft=true;
				document.getElementById('viewport').appendChild(renderer.domElement);

				scene = new Physijs.Scene;
				scene.setGravity(new THREE.Vector3(0,-1,0));
				scene.addEventListener('update',function(){
					scene.simulate(undefined,1);
				});

				camera = new THREE.PerspectiveCamera(35,window.innerWidth/window.innerHeight,1,1000);
				camera.position.set(120,100,120);
				camera.lookAt(scene.position);
				scene.add(camera);

				// Light
				light = new THREE.DirectionalLight( 0xFFFFFF );
				light.position.set( 20, 40, -15 );
				light.target.position.copy( scene.position );
				light.castShadow = true;
				light.shadowCameraLeft = -60;
				light.shadowCameraTop = -60;
				light.shadowCameraRight = 60;
				light.shadowCameraBottom = 60;
				light.shadowCameraNear = 20;
				light.shadowCameraFar = 200;
				light.shadowBias = -.0001
				light.shadowMapWidth = light.shadowMapHeight = 2048;
				light.shadowDarkness = .7;
				scene.add( light );

				table_material = Physijs.createMaterial(
					new THREE.MeshBasicMaterial({map:THREE.ImageUtils.loadTexture('images/table.png')}),
					0, //friction
					1.1  //restitution
					);
				table_material.map.wrapS=table_material.map.wrapT=THREE.RepeatWrapping;
				//table_material.map.repeat.set(3,3);

				table = new Physijs.BoxMesh(
						new THREE.CubeGeometry(200,1,100),
						table_material,
						0//mass
					);
				table.receiveShadow.true;
				scene.add(table);

				var paddle_material=Physijs.createMaterial(
					new THREE.MeshBasicMaterial({map:THREE.ImageUtils.loadTexture('images/net.png')}),
					0,
					1.2
					);
				var paddleFar = new Physijs.BoxMesh(
					new THREE.CubeGeometry(200,1,100),
					paddle_material,
					0);
				paddleFar.receiveShadow.true;
				paddleFar.position.set(-100,0,0);
				paddleFar.rotation.set(0,0,Math.PI/2);
				paddleFar.addEventListener('collision',function(){
					forceVelocity=0;
					scene.setGravity(0,-30,0);
				});

				var paddle_material2=Physijs.createMaterial(
					new THREE.MeshBasicMaterial({map:THREE.ImageUtils.loadTexture('images/net.png')}),
					0,
					1.2
					);
				var paddleNear = new Physijs.BoxMesh(
					new THREE.CubeGeometry(200,1,100),
					paddle_material2,
					0);
				paddleNear.receiveShadow.true;
				paddleNear.position.set(100,0,0);
				paddleNear.rotation.set(0,0,Math.PI/2);
				paddleNear.addEventListener('collision',function(){
					console.log("PADDLE COLLISION");
					forceVelocity=0;
					scene.setGravity(0,-10,0);
				});

				scene.add(paddleFar);
				scene.add(paddleNear);

				spawnBall();

				requestAnimationFrame(render);
				scene.simulate();
			};
			

			spawnBall = (function() {
		var ball_geometry = new THREE.SphereGeometry( 4,10,10),
			handleCollision = function( collided_with, linearVelocity, angularVelocity ) {
				//console.log(collided_with);
				//console.log("OIJWER",linearVelocity);
				if(collided_with!=table){
					console.log("paddle",linearVelocity);
					//ball.setLinearVelocity(-1*linearVelocity.x,linearVelocity.y,linearVelocity.z);
				}
				else{
					console.log("TABLE",linearVelocity);
					//ball.setLinearVelocity(linearVelocity.x,-1*linearVelocity.y, linearVelocity.z);
				}
				//console.log(angularVelocity);
				/*switch ( ++this.collisions ) {
					
					case 1:
						this.material.color.setHex(0xcc8855);
						break;
					
					case 2:
						this.material.color.setHex(0xbb9955);
						break;
					
					case 3:
						this.material.color.setHex(0xaaaa55);
						break;
					
					case 4:
						this.material.color.setHex(0x99bb55);
						break;
					
					case 5:
						this.material.color.setHex(0x88cc55);
						break;
					
					case 6:
						this.material.color.setHex(0x77dd55);
						break;
				}*/
			},
			createBall = function() {
				var material;
				
				material = Physijs.createMaterial(
					new THREE.MeshLambertMaterial({ color:0xffffff}),
					0, // medium friction
					1.3 // low restitution
				);
				//material.map.wrapS = material.map.wrapT = THREE.RepeatWrapping;
				//material.map.repeat.set( .5, .5 );
				
				//material = new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/rocks.jpg' ) });
				
				ball = new Physijs.SphereMesh(
					ball_geometry,
					material,
					.1
				);
				ball.collisions = 0;
				
				ball.position.set(
					Math.random() * 15 - 7.5,
					25,
					Math.random() * 15 - 7.5
				);
				
				ball.rotation.set(
					Math.random() * Math.PI,
					Math.random() * Math.PI,
					Math.random() * Math.PI
				);

				var constraint = new Physijs.SliderConstraint(
					ball,table,new THREE.Vector3(0,10,0), new THREE.Vector3(1,0,0)
					);
				constraint.scene=scene;
				console.log(scene==null);
				scene.addConstraint(constraint);
				constraint.enableLinearMotor(1,0);
				
				ball.castShadow = true;
				ball.addEventListener( 'collision', handleCollision );
				console.log(ball, ball._physijs.linearVelocity);
				
				//ball.addEventListener( 'ready', spawnBall );
				scene.add( ball );
				ball.setLinearVelocity(new THREE.Vector3(-200,0,0));
				console.log(ball);
			};
		
		return function() {
			//createBall();
			setTimeout( createBall, 1000 );
		};
	})();
			render = function() {
				requestAnimationFrame( render );
				//ball.__dirtyPosition = true;
				//ball.position.x-=3*forceVelocity;
				renderer.render( scene, camera );
				//render_stats.update();
			};
			window.onload = initScene;
		</script>
	</head>
	<body>
		<div id="viewport"></div>
	</body>
</html>